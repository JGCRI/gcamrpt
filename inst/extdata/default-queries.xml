<?xml version="1.0" encoding="UTF-8"?>
<queries>
	<aQuery>
		<all-regions/>
		<gdpQueryBuilder title="GDP(MER)">
			<axis1 name="region">region</axis1>
			<axis2 name="year">gdp-mer</axis2>
			<xPath buildList="true" dataName="gdp-mer" group="false" sumAll="false">GDP/gdp-mer/text()</xPath>
			<comments/>
        	</gdpQueryBuilder>
	</aQuery>

	<aQuery>
    		<all-regions/>
    		<gdpQueryBuilder title="pcGDP(PPP)">
			<axis1 name="region">region</axis1>
			<axis2 name="year">gdp-per-capita-ppp</axis2>
			<xPath buildList="true" dataName="gdp-per-capita-ppp" group="false" sumAll="false">GDP/gdp-per-capita-ppp/text()</xPath>
			<comments/>
		</gdpQueryBuilder>
	</aQuery>

	<aQuery>
		<all-regions/>
        	<demographicsQuery title="Population">
			<axis1 name="region">region</axis1>
			<axis2 name="year">populationMiniCAM</axis2>
			<xPath buildList="true" dataName="total-population" group="false" sumAll="false">demographics/populationMiniCAM/total-population/node()</xPath>
			<comments/>
        	</demographicsQuery>
	</aQuery>

	<aQuery>
		<all-regions/>
	  <supplyDemandQuery title="Electricity">
            <axis1 name="region">region</axis1>
            <axis2 name="year">physical-output[@vintage]</axis2>
            <xPath buildList="true" dataName="output" group="false" sumAll="false">*[@type = 'sector' and ((@name='electricity' or @name='elect_td_bld' or @name='industrial energy use'))]//*[@type = 'subsector']//*[@type = 'technology' and not (@name='elect_td_bld')]/*[@type='output' (:collapse:)  and (@name='electricity' or @name='elect_td_bld')]/physical-output/node()</xPath>
            <comments/>
	  </supplyDemandQuery> 
	</aQuery>

      <aQuery>
		<all-regions/>
		<supplyDemandQuery title="Transportation Service Output">
			<axis1 name="technology">technology</axis1>
			<axis2 name="year">physical-output[@vintage]</axis2>
			<xPath buildList="true" dataName="output" group="false" sumAll="false">*[@type = 'sector' and (@name='transportation' or (exists(child::keyword[@final-energy='transportation'])))]/*[@type = 'subsector']/*[@type = 'technology']/*[@type='output' (:collapse:) and not(@name='CAFEcredit')]/physical-output/node()</xPath>
			<comments/>
			<showAttribute attribute-name="year" level="technology"/>
		</supplyDemandQuery>
      </aQuery>


	     <aQuery>
		<all-regions/>
		<supplyDemandQuery title="Transportation Load Factors">
			<axis1 name="technology">technology</axis1>
			<axis2 name="year">technology</axis2>
			<xPath buildList="true" dataName="output" group="false" sumAll="false">*[@type = 'sector' and (@name='transportation' or (exists(child::keyword[@final-energy='transportation'])))]/*[@type = 'subsector']/*[@type = 'technology']//load-factor/node()</xPath>
			<comments/>
		</supplyDemandQuery>
      </aQuery>

      <aQuery>
		<all-regions/>
		<supplyDemandQuery title="Transportation Final Energy">
			<axis1 name="technology">technology</axis1>
			<axis2 name="year">demand-physical[@vintage]</axis2>
			<xPath buildList="true" dataName="input" group="false" sumAll="false">*[@type = 'sector' and (@name='transportation' or (exists(child::keyword[@final-energy='transportation'])))]/*[@type = 'subsector']/*[@type = 'technology']/*[@type='input' and not (@name='renewable')]/demand-physical[@unit='EJ']/node()</xPath>
			<comments/>
			<showAttribute attribute-name="year" level="technology"/>
		</supplyDemandQuery>
      </aQuery>

	<aQuery>
		<all-regions/>
		<supplyDemandQuery title="Refined Liquids">
			<axis1 name="subsector">subsector</axis1>
			<axis2 name="year">physical-output[@vintage]</axis2>
			<xPath buildList="true" dataName="output" group="false" sumAll="false">*[@type = 'sector' (:collapse:) and ((@name='refining'))]/*[@type = 'subsector']//*[@type='output' (:collapse:)]/physical-output/node()</xPath>
			<comments/>
		</supplyDemandQuery>
      </aQuery>

	<aQuery>
		<all-regions/>
 		<emissionsQueryBuilder title="CO2 emissions">
         <axis1 name="subsector">subsector</axis1>
         <axis2 name="Year">emissions</axis2>
         <xPath buildList="true" dataName="emissions" group="false" sumAll="false">*[@type = 'sector' ]/*[@type='subsector']//CO2/emissions/node()</xPath>
         <comments/>
      </emissionsQueryBuilder>
      </aQuery>

<aQuery>
	<all-regions/>
      <supplyDemandQuery title="Final energy by detailed end-use sector and fuel">
         <axis1 name="sector">sector</axis1>
         <axis2 name="Year">demand-physical[@vintage]</axis2>
         <xPath buildList="true" dataName="input" group="false" sumAll="false">*[@type='sector' and ((@name='building' or @name='industry' or @name='transportation') or (exists(child::keyword/@final-energy)))]//*[@type='input' and not(@name='trn_pass_road' or @name='limestone' or @name='process heat cement' or @name='industrial energy use' or @name='industrial feedstocks' or @name='renewable')]/demand-physical[@unit='EJ']/node()</xPath>
         <comments/>
      </supplyDemandQuery>
      </aQuery>

      	<aQuery>
		<all-regions/>
      <supplyDemandQuery title="Building floorspace">
         <axis1 name="Building">gcam-consumer[@name]</axis1>
         <axis2 name="Year">floorspace[@year]</axis2>
         <xPath buildList="true" dataName="floorspace" group="false" sumAll="false">gcam-consumer//floorspace/node()</xPath>
         <comments/>
      </supplyDemandQuery>
      </aQuery>


      	<aQuery>
		<all-regions/>
      <supplyDemandQuery title="Resource production">
         <axis1 name="resource">resource</axis1>
         <axis2 name="Year">output</axis2>
         <xPath buildList="true" dataName="output" group="false" sumAll="false">*[@type='resource']//output/node()</xPath>
         <comments/>
      </supplyDemandQuery>
      </aQuery>

      <aQuery>
		<all-regions/>
      <emissionsQueryBuilder title="GHG emissions by subsector">
         <axis1 name="sector">sector</axis1>
         <axis2 name="Year">emissions</axis2>
         <xPath buildList="true" dataName="emissions" group="false" sumAll="false"> 
			 	 	 <![CDATA[declare function local:deep-copy($nodes as node()*) as node()* {
                         for $node in $nodes
                         return typeswitch($node)
                         case $e as element()
                             return element { local-name($e) } {
                                 $e/@*,
                                 for $c in $e/(* | text())
                                 return local:deep-copy($c)
                             }
                         default return $node
                     };
			 	 	 declare function local:rename-resource-emiss($resources as node()*) as node()* {
					         for $resource in $resources
			 	 		 let $scn := $resource/ancestor::scenario,
			 			     $rgn := $resource/ancestor::region,
			 			     $retDoc := document { element scenario {
									$scn/@*,
									element region {
										$rgn/@*,
										element sector {
										        attribute type { 'sector' },
											$resource/@name,
											element subsector {
												attribute type { 'subsector' },
												$resource/@name,
												element technology {
													attribute type { 'technology' },
													$resource/@name,
													local:deep-copy($resource/*[@type='GHG'])
			 			 						}
			 			 	  				}
										}
									}
								}
							}
			 			 return
						     $retDoc//text()
			 	 	 };  
			 	 	 declare function local:run-combine-sector-resource-emiss($scenarios as xs:string*, $regions as xs:string*, $collection as xs:string) as node()* { 	
			 	 	 let $regionsG := if(not($regions[1] = 'Global'))
			 	 	 		  then $regions
			 	 	 		  else distinct-values(collection($collection)/scenario/world/*[@type='region']/@name)
			 	 	 return
			 	 	 for $scenario in $scenarios, 	    
			 	 	 $region in $regionsG 	
			 	 	 let $scenario_split := tokenize($scenario, ' '), 	    
                     $scenario_name := string-join($scenario_split[position() < last()], ' '),
			 	 	 $scenario_date := $scenario_split[last()],
			 	 	 $currTree := collection($collection)/scenario[@name = $scenario_name and @date = $scenario_date]/world/*[@type = 'region' and @name=$region]
					 return (: rename resources as a sector/subsector/tech :)
						local:rename-resource-emiss($currTree/*[@type='resource' and exists(child::*[@type='GHG'])])
						| (: get the sector emissions :)
						$currTree/*[@type = 'sector' ]/*[@type='subsector']//*[@type = 'GHG']/emissions/node()
	 	 }; 
            	 local:run-combine-sector-resource-emiss((:scenarios:), (:regions:), (:collection:))]]>
		 </xPath>
         <comments/>
      </emissionsQueryBuilder>
      </aQuery>

    <aQuery>
	  <all-regions/>
      <supplyDemandQuery title="Cement production by region">
         <axis1 name="region">region</axis1>
         <axis2 name="Year">physical-output[@vintage]</axis2>
         <xPath buildList="true" dataName="output" group="false" sumAll="false">*[@type = 'sector' and (@name='cement')]//*[@type='output' (:collapse:)]/physical-output/node()</xPath>
         <comments/>
      </supplyDemandQuery>
    </aQuery>

     <aQuery>
		<all-regions/>
      	<supplyDemandQuery title="Primary Energy Consumption (Direct Equivalent)">
         <axis1 name="fuel">input[@name]</axis1>
         <axis2 name="Year">demand-physical[@vintage]</axis2>
         <xPath buildList="true" dataName="input" group="false" sumAll="false"> 
			 	 	 <![CDATA[declare function local:append-heirarchy($parent as node(), $append as node()) as node() {
			 	 		 let $scn := $parent/ancestor::scenario,
			 			   	  $rgn := $parent/ancestor::region
			 			   return
			 			   	  document { element scenario {
			 			 	  					$scn/@*,
			 			 						element region {
			 			 							$rgn/@*,
			 			 							$append
			 			 						}
			 			 	  				}
			 				}
			 	 	 };  
			 	 	 declare function local:get-primary-renewable($outputs as node()*) as node()* {
			 	 	 unordered { 	
			 	 	 for $output in $outputs 
			 	 	 let $new_output :=  
			 	 	 element input {
			 	 		 attribute type {'input'},
			 	 		 attribute name {$output/parent::*/following-sibling::keyword/@primary-renewable},
			 	 		 element demand-physical {
			 	 			 attribute vintage {$output/@vintage},
			 	 			 attribute unit {$output/@unit},
			 	 			 text { $output }
			 	 		 }
			 	 	 },
			 	 	 $new_root := local:append-heirarchy($output/parent::*/parent::*, $new_output)
			 	 	 return $new_root//text()
			 	 	 } 
			 	 	 };
			 	 	 declare function local:run-primary-energy($scenarios as xs:string*, $regions as xs:string*, $collection as xs:string) as node()* { 	
			 	 	 let $regionsG := if(not($regions[1] = 'Global'))
			 	 	 		  then $regions
			 	 	 		  else distinct-values(collection($collection)/scenario/world/*[@type='region']/@name)
			 	 	 return
			 	 	 for $scenario in $scenarios, 	    
			 	 	 $region in $regionsG 	
			 	 	 let $scenario_split := tokenize($scenario, ' '), 	    
                     $scenario_name := string-join($scenario_split[position() < last()], ' '),
			 	 	 $scenario_date := $scenario_split[last()],
			 	 	 $currTree := collection($collection)/scenario[@name = $scenario_name and @date = $scenario_date]/world/*[@type = 'region' and @name=$region]
			 	 	 return (: get renewables from electricity :)
					 	 	 	local:get-primary-renewable($currTree/supplysector[@name='electricity' or @name='elect_td_bld']//keyword[fn:exists(@primary-renewable)]/preceding-sibling::output-primary/physical-output)
					 		 	| (: get renewables from H2ProdCS :)
					 	 	 	local:get-primary-renewable($currTree/supplysector[@name='H2 central production'](: /*[@type='subsector' (: collapse :) and fn:not(@name='electrolysis')] :)//keyword[fn:exists(@primary-renewable)]/preceding-sibling::output-primary/physical-output)
					 	 	 	| (: get renewables from H2ProdDist :)
					 	 	 	local:get-primary-renewable($currTree/supplysector[@name='H2 forecourt production'](: /*[@type='subsector' (: collapse :) and fn:not(@name='electrolysis')] :)//keyword[fn:exists(@primary-renewable)]/preceding-sibling::output-primary/physical-output)
					 	 	 	| (: get the primaries :)
	 	 						$currTree//keyword[fn:exists(@primary-consumption)]/preceding-sibling::input-energy/demand-physical/text()
                                | (: get traditional biomass :)
							    $currTree//*[@type='input' and @name='traditional biomass']/demand-physical/node()
			 	 	 	
	 	 }; 
            	 local:run-primary-energy((:scenarios:), (:regions:), (:collection:))]]>
            </xPath>
         <comments/>
         <labelRewriteList append-values="false">
            <level name="input">
               <rewrite from="exotic-elect" to="Breakthrough"/>
               <rewrite from="wind-H2" to="Wind"/>
               <rewrite from="biomass" to="Biomass"/>
               <rewrite from="traditional biomass" to="Traditional Biomass"/>
               <rewrite from="crude oil" to="Oil"/>
               <rewrite from="nuclear-elect" to="Nuclear"/>
               <rewrite from="solar-H2" to="Solar"/>
               <rewrite from="regional natural gas" to=""/>
               <rewrite from="traded unconventional oil" to="Oil"/>
               <rewrite from="geothermal-elect" to="Geothermal"/>
               <rewrite from="natural gas" to="Natural Gas"/>
               <rewrite from="hydro-elect" to="Hydro"/>
               <rewrite from="solar-elect" to="Solar"/>
               <rewrite from="coal" to="Coal"/>
               <rewrite from="elect_td_ind" to=""/>
               <rewrite from="wind-elect" to="Wind"/>
               <rewrite from="nuclear-H2" to="Nuclear"/>
               <rewrite from="k new" to="New"/>
            </level>
         </labelRewriteList>
      </supplyDemandQuery>
      </aQuery>

	<aQuery>
		<all-regions/>
      <supplyDemandQuery title="Final energy by detailed end-use sector and fuel">
         <axis1 name="sector">sector</axis1>
         <axis2 name="Year">demand-physical[@vintage]</axis2>
         <xPath buildList="true" dataName="input" group="false" sumAll="false">*[@type='sector' and ((@name='building' or @name='industry' or @name='transportation') or (exists(child::keyword/@final-energy)))]//*[@type='input' and not(@name='trn_pass_road' or @name='limestone' or @name='process heat cement' or @name='industrial energy use' or @name='industrial feedstocks' or @name='renewable')]/demand-physical[@unit='EJ']/node()</xPath>
         <comments/>
      </supplyDemandQuery>
      </aQuery>

	<aQuery>
		<all-regions/>
<supplyDemandQuery title="CO2 Emissions by enduse">
         <axis1 name="sector">sector[@name]</axis1>
         <axis2 name="Year">emissions[@year]</axis2>
         <xPath buildList="true" dataName="input" group="false" sumAll="false">
               <![CDATA[declare function local:append-heirarchy($parent as node(), $append as node()*) as node() {
	       	 		 let $scn := $parent/ancestor::scenario,
	       			   	  $rgn := $parent (: /ancestor::region :)
	       			   return
	       			   	  document { element scenario {
	       			 	  					$scn/@*,
	       			 						element region {
	       			 							$rgn/@*,
	       			 							$append
	       			 						}
	       			 	  				}
	       				}
	       	 		 (: I can get by with just the scenario and region
	       			 let $new_node := element {local-name($parent)} {$parent/@*, $append} 	
	       	 		 return
	       	 		 if(local-name($parent) != 'scenario')
	       	 		 then local:append-heirarchy($parent/parent::*, $new_node)
	       	 		 else document { $new_node } :)
	       	 	 }; 
	       	 	 declare function local:generate-sector-output-coefs($inputNameQueue as xs:string*, $currTree as node(), $coefs as node()*, $is_usa as xs:boolean) as node()* {
                 if(empty($inputNameQueue)) then $coefs
                 else if( exists($coefs[@name = $inputNameQueue[1]]) or exists(index-of(('unconventional oil production', "electricity", "cement", "N fertilizer"),
$inputNameQueue[1])) or not($currTree/*[@type='sector' and @name=$inputNameQueue[1]]))
then 
local:generate-sector-output-coefs(remove($inputNameQueue, 1), $currTree, $coefs, $is_usa)
	       				else
                    let $inputName := $inputNameQueue[1],
                        $newInputNameQueue := remove($inputNameQueue, 1),
                        $useInputs := $currTree//*[@type='input' and @name=$inputName],
                        $useSectors := distinct-values($useInputs/ancestor::*[@type='sector']/@name),
                        $totalInputSum := for $vintage in distinct-values($useInputs/demand-physical/@vintage)
                                          return element input {
                                                     attribute vintage { $vintage },
                                                     text {
                                                         sum($useInputs/demand-physical[@vintage=$vintage])
                                                     }
                                                 },
                       $new_coefs := if(empty($useSectors)) then
                                         $coefs
                                     else
                                         $coefs | element sector {
                                            attribute name { $inputName },
                                            for $output in $useSectors
                                            return element output {
                                                       attribute name { $output },
                                                       for $inputSum in $totalInputSum
                                                       let $outputSum := sum($useInputs[ancestor::*[@type='sector' and @name=$output]]/demand-physical[@vintage=$inputSum/@vintage])
                                                       return element coef {
                                                                  attribute vintage { $inputSum/@vintage },
                                                                  text { $outputSum div $inputSum }
                                                              }
                                                    }
                                        }
                        return 
                              local:generate-sector-output-coefs(distinct-values(($newInputNameQueue, $useSectors)), $currTree, $new_coefs, $is_usa)
		};
        declare function local:apply-coefs($outputName as xs:string, $emissions as node()*, $coefs as node()*) as node()* {
            if(exists($coefs[@name=$outputName]) and abs(sum($emissions)) > 0.001) then
                for $output in $coefs[@name=$outputName]/output
                return local:apply-coefs($output/@name,
                    for $year in distinct-values($emissions/@year)
                    let $emissThisVintage := $emissions[@year=$year],
                        $firstEmiss := $emissThisVintage[1],
                        $emissSum := sum($emissThisVintage),
                        $coefThisVintage := $output/coef[@vintage=$year]
                    where $coefThisVintage > 0
                    return element { local-name($firstEmiss) } {
                            $firstEmiss/@*,
                            text{ $emissSum * $coefThisVintage }
                        }
	       			, $coefs)
            else if( abs(sum($emissions)) > 0.001) then
                element sector {
                    attribute name { $outputName },
                    attribute type { 'sector' },
                    (: $emissions :) (: TODO: not sure why this doesn't work and we need to create these explicitly :)
                    for $e in $emissions
                    return element emissions { $e/@*, text{ $e/text() } }
                }
            else
                (: These are the residuals from chasing simulenaties, I've left this here
                   for debuging purposes :)
                element sector {
                    attribute name { $outputName },
                    attribute type { 'sector' }(:,
                    $emissions:)
                }
        };
		declare function local:run-emiss-by-enduse($scenarios as xs:string*, $regions as xs:string*, $collection as xs:string) as node()* { 	
			 	 unordered { 	
			 	 let $regionsG := if(not($regions[1] = 'Global'))
			 	 		  then $regions
			 	 		  else distinct-values(collection($collection)/scenario/world/*[@type='region']/@name)
			 	 return
			 	 for $scenario in $scenarios, 	    
			 	 $region in $regionsG 	
			 	 let $scenario_split := tokenize($scenario, ' '), 	    
				 $currTree := collection($collection)/scenario[@name = $scenario_split[1] and @date = $scenario_split[2]]/world/*[@type='region' and @name=$region],
                 $currEmissSectors := $currTree/*[@type='sector' and descendant::CO2],
                 $coefs := local:generate-sector-output-coefs(distinct-values($currEmissSectors/@name), $currTree, (), false())
				 return
				    for $sectorName in distinct-values($currEmissSectors/@name)
                    return local:append-heirarchy($currTree, local:apply-coefs($sectorName, $currEmissSectors[@name=$sectorName]//CO2/emissions, $coefs))//text()
			 	 } 
	 	 };
		 local:run-emiss-by-enduse((:scenarios:), (:regions:), (:collection:))]]>
               </xPath>
         <comments/>
         <labelRewriteList append-values="false">
            <level name="sector">
               <rewrite from="trn_pass_road_LDV_4W" to="transportation"/>
               <rewrite from="trn_pass_road" to="transportation"/>
               <rewrite from="trn_freight_road" to="transportation"/>
               <rewrite from="trn_pass_road_LDV_2W" to="transportation"/>
               <rewrite from="trn_passenger" to="transportation"/>
               <rewrite from="trn_freight" to="transportation"/>
               <rewrite from="comm others" to="buildings"/>
               <rewrite from="comm heating" to="buildings"/>
               <rewrite from="comm cooling" to="buildings"/>
               <rewrite from="trn_pass_road_LDV" to="transportation"/>
               <rewrite from="trn_aviation_intl" to="transportation"/>
               <rewrite from="trn_pass_road_bus" to="transportation"/>
               <rewrite from="trn_pass" to="transportation"/>
               <rewrite from="N fertilizer" to="industry"/>
               <rewrite from="resid heating" to="buildings"/>
               <rewrite from="resid others" to="buildings"/>
               <rewrite from="unconventional oil production" to="industry"/>
               <rewrite from="resid cooling" to="buildings"/>
               <rewrite from="trn_shipping_intl" to="transportation"/>
               <rewrite from="cement" to="industry"/>
            </level>
         </labelRewriteList>
      </supplyDemandQuery>
      </aQuery>

<aQuery>
		<all-regions/>
       <emissionsQueryBuilder title="GHG emissions by sector">
         <axis1 name="sector">sector</axis1>
         <axis2 name="Year">emissions</axis2>
         <xPath buildList="true" dataName="emissions" group="false" sumAll="false"> 
			 	 	<![CDATA[declare function local:deep-copy($nodes as node()*) as node()* {
                         for $node in $nodes
                         return typeswitch($node)
                         case $e as element()
                             return element { local-name($e) } {
                                 $e/@*,
                                 for $c in $e/(* | text())
                                 return local:deep-copy($c)
                             }
                         default return $node
                     };
			 	 	 declare function local:rename-resource-emiss($resources as node()*) as node()* {
					         for $resource in $resources
			 	 		 let $scn := $resource/ancestor::scenario,
			 			     $rgn := $resource/ancestor::region,
			 			     $retDoc := document { element scenario {
									$scn/@*,
									element region {
										$rgn/@*,
										element sector {
										        attribute type { 'sector' },
											$resource/@name,
											element subsector {
												attribute type { 'subsector' },
												$resource/@name,
												element technology {
													attribute type { 'technology' },
													$resource/@name,
													local:deep-copy($resource/*[@type='GHG'])
			 			 						}
			 			 	  				}
										}
									}
								}
							}
			 			 return
						     $retDoc//text()
			 	 	 };  
			 	 	 declare function local:run-combine-sector-resource-emiss($scenarios as xs:string*, $regions as xs:string*, $collection as xs:string) as node()* { 	
			 	 	 let $regionsG := if(not($regions[1] = 'Global'))
			 	 	 		  then $regions
			 	 	 		  else distinct-values(collection($collection)/scenario/world/*[@type='region']/@name)
			 	 	 return
			 	 	 for $scenario in $scenarios, 	    
			 	 	 $region in $regionsG 	
			 	 	 let $scenario_split := tokenize($scenario, ' '), 	    
                     $scenario_name := string-join($scenario_split[position() < last()], ' '),
			 	 	 $scenario_date := $scenario_split[last()],
			 	 	 $currTree := collection($collection)/scenario[@name = $scenario_name and @date = $scenario_date]/world/*[@type = 'region' and @name=$region]
					 return (: rename resources as a sector/subsector/tech :)
						local:rename-resource-emiss($currTree/*[@type='resource' and exists(child::*[@type='GHG'])])
						| (: get the sector emissions :)
						$currTree/*[@type = 'sector']//*[@type = 'GHG']/emissions/node()
	 	 }; 
            	 local:run-combine-sector-resource-emiss((:scenarios:), (:regions:), (:collection:))]]>
	 </xPath>
         <comments/>
      </emissionsQueryBuilder>
      </aQuery>

      <aQuery>
      	<all-regions/>
      	 <supplyDemandQuery title="Net Zero Bio CO2 Emissions by Sector">
         <axis1 name="Primary Fuel">sector[@name]</axis1>
         <axis2 name="Year">emissions[@year]</axis2>
         <xPath buildList="true" dataName="input" group="false" sumAll="false">
               <![CDATA[declare function local:append-heirarchy($parent as node(), $append as node()*) as node() {
	       	 		 let $scn := $parent/ancestor::scenario,
	       			   	  $rgn := $parent (: /ancestor::region :)
	       			   return
	       			   	  document { element scenario {
	       			 	  					$scn/@*,
	       			 						element region {
	       			 							$rgn/@*,
	       			 							$append
	       			 						}
	       			 	  				}
	       				}
	       	 		 (: I can get by with just the scenario and region
	       			 let $new_node := element {local-name($parent)} {$parent/@*, $append} 	
	       	 		 return
	       	 		 if(local-name($parent) != 'scenario')
	       	 		 then local:append-heirarchy($parent/parent::*, $new_node)
	       	 		 else document { $new_node } :)
	       	 	 }; 
                 declare function local:get-carbon-coef($good as xs:string) as xs:decimal {
                     let $carbonCoefs := (
            <PrimaryFuelCO2Coef name="biomass">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="coal">27.3</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="crude oil">19.6</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="delivered biomass">23</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="delivered coal">27.3</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="delivered gas">14.2</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="delivered pet prods">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="distributed_solar">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="gas pipeline">14.2</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="gas processing">14.2</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="geothermal">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="global solar resource">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="large onshore windresource">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="limestone">79.802</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="natural gas">14.2</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="nuclearFuelGenII">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="refined liquids enduse">19.6</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="refined liquids industrial">19.6</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="refining">19.6</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="refined oil">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional biomass">23</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional biomassOil">23</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional coal">27.3</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional corn for ethanol">23</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional crude oil">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional natural gas">14.2</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional oil">19.6</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional sugar for ethanol">23</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="regional sugarbeet for ethanol">23</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="shale oil">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="shale oil regional">0</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="traded unconventional oil">19.6</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="unconventional oil">21.1</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="unconventional oil production">19.6</PrimaryFuelCO2Coef>,
            <PrimaryFuelCO2Coef name="wholesale gas">14.2</PrimaryFuelCO2Coef>),
                        $currCoef := $carbonCoefs[@name=$good]/text()
                     return if(exists($currCoef)) then $currCoef else 0.0
                 };


                 declare function local:is-carbonatious-fuel($good as xs:string) as xs:boolean {
                     (:
                     exists(index-of(('delivered biomass', 'delivered coal', 'delivered gas', 'gas pipeline', 'gas processing', 'gas processing', 'refined liquids enduse',
                     'refined liquids industrial', 'refining', 'regional biomass', 'regional biomassOil', 'regional oil', 'wholesale gas'), $good)):)
                     not(local:get-carbon-coef($good) = 0.0)
                 };
	       	 	 declare function local:generate-sector-output-coefs($inputNameQueue as xs:string*, $currTree as node(), $coefs as node()*, $is_usa as xs:boolean) as node()* {
                 if(empty($inputNameQueue)) then $coefs
                 else if( exists($coefs[@name = $inputNameQueue[1]]) or exists(index-of(('traded unconventional oil'),
$inputNameQueue[1])) or not($currTree/*[@type='sector' and @name=$inputNameQueue[1]]) or not(local:is-carbonatious-fuel($inputNameQueue[1])))
then 
(:if(not($is_usa) and string-length($currTree/@name) = 2) then
local:trace-inputs($outputName, $currTree/parent::*/*[@type='region' and @name='USA'], $outputs, true())
else:)
local:generate-sector-output-coefs(remove($inputNameQueue, 1), $currTree, $coefs, $is_usa)
	       				else
                    let $inputName := $inputNameQueue[1],
                        $newInputNameQueue := remove($inputNameQueue, 1),
                        $useInputs := $currTree//*[@type='input' and @name=$inputName],
                        $useSectors := distinct-values($useInputs/ancestor::*[@type='sector']/@name),
                        $totalInputSum := for $vintage in distinct-values($useInputs/demand-physical/@vintage)
                                          return element input {
                                                     attribute vintage { $vintage },
                                                     text {
                                                         sum($useInputs/demand-physical[@vintage=$vintage])
                                                     }
                                                 },
                       $new_coefs := if(empty($useSectors)) then
                                         $coefs
                                     else
                                         $coefs | element sector {
                                            attribute name { $inputName },
                                            for $output in $useSectors
                                            return element output {
                                                       attribute name { $output },
                                                       for $inputSum in $totalInputSum
                                                       let $currSectorInputs := $useInputs[ancestor::*[@type='sector' and @name=$output]],
                                                           $outputSum := sum($currSectorInputs/demand-physical[@vintage=$inputSum/@vintage]),
                                                           $carbonIn := sum($currSectorInputs/parent::*//carbon-content[@vintage=$inputSum/@vintage]),
                                                           $carbonOut := sum($currSectorInputs/parent::*/output-primary/physical-output[@vintage=$inputSum/@vintage]) *
                                                               local:get-carbon-coef($output)
                                                       return (element share {
                                                                  attribute vintage { $inputSum/@vintage },
                                                                  text { $outputSum div $inputSum }
                                                              }, element carbon_ratio {
                                                                  attribute vintage { $inputSum/@vintage },
                                                                  text{ if($carbonIn > 0) then $carbonOut div $carbonIn else 0 }
                                                              })
                                                    }
                                        }
                        return 
                              local:generate-sector-output-coefs(distinct-values(($newInputNameQueue, $useSectors)), $currTree, $new_coefs, $is_usa)
		};
        declare function local:apply-coefs($outputName as xs:string, $emissions as node()*, $coefs as node()*) as node()* {
            if(exists($coefs[@name=$outputName]) and abs(sum($emissions)) > 0.001) then
                for $output in $coefs[@name=$outputName]/output
                let $emiss_go := for $year in distinct-values($emissions/@year)
                    let $emissThisVintage := $emissions[@year=$year],
                        $firstEmiss := $emissThisVintage[1],
                        $emissSum := sum($emissThisVintage),
                        $shareThisVintage := $output/share[@vintage=$year],
                        $carbonRatioThisVintage := $output/carbon_ratio[@vintage=$year],
                        $coefThisVintage := $shareThisVintage * $carbonRatioThisVintage
                    where $coefThisVintage > 0
                    return element { local-name($firstEmiss) } {
                            $firstEmiss/@*,
                            text{ $emissSum * $coefThisVintage }
                        },
                    $emiss_stay := for $year in distinct-values($emissions/@year)
                    let $emissThisVintage := $emissions[@year=$year],
                        $firstEmiss := $emissThisVintage[1],
                        $emissSum := sum($emissThisVintage),
                        $shareThisVintage := $output/share[@vintage=$year],
                        $carbonRatioThisVintage := 1.0 - $output/carbon_ratio[@vintage=$year],
                        $coefThisVintage := $shareThisVintage * $carbonRatioThisVintage 
                    where $coefThisVintage > 0
                    return element { local-name($firstEmiss) } {
                            $firstEmiss/@*,
                            text{ $emissSum * $coefThisVintage }
                        }
                    return local:apply-coefs($output/@name, $emiss_go, $coefs) |
                        element sector {
                            attribute name { $output/@name},
                            attribute type { 'sector' },
                            $emiss_stay
                        }
            else if( abs(sum($emissions)) > 0.001) then
                element sector {
                    attribute name { $outputName },
                    attribute type { 'sector' },
                    $emissions
                }
            else
                (: These are the residuals from chasing simulenaties, I've left this here
                   for debuging purposes :)
                element sector {
                    attribute name { $outputName },
                    attribute type { 'sector' }(:,
                    $emissions:)
                }
        };
		declare function local:run-emiss-by-enduse($scenarios as xs:string*, $regions as xs:string*, $collection as xs:string) as node()* { 	
			 	 unordered { 	
			 	 let $regionsG := if(not($regions[1] = 'Global'))
			 	 		  then $regions
			 	 		  else distinct-values(collection($collection)/scenario/world/*[@type='region']/@name)
			 	 return
			 	 for $scenario in $scenarios, 	    
			 	 $region in $regionsG 	
			 	 let $scenario_split := tokenize($scenario, ' '), 	    
				 $currTree := collection($collection)/scenario[@name = $scenario_split[1] and @date = $scenario_split[2]]/world/*[@type='region' and @name=$region],
                 $biomassSectors := ('regional biomass', 'regional biomassOil', 'regional corn for ethanol', 'regional sugar for ethanol', 'regional sugarbeet for ethanol'),
                 $currEmissSectors := $currTree/*[@type='sector' and exists(index-of($biomassSectors, @name))],
                 $coefs := local:generate-sector-output-coefs(distinct-values($currEmissSectors/@name), $currTree, (), false()),
                 $downstream_emiss := for $sectorName in distinct-values($currEmissSectors/@name)
                                      return local:append-heirarchy($currTree, local:apply-coefs($sectorName, $currEmissSectors[@name=$sectorName]//CO2/emissions, $coefs))//text()
                 return $downstream_emiss | 
                 $currTree/*[@type='sector' and empty(index-of($biomassSectors, @name))]//CO2[@type='GHG' (: collapse :)]/emissions/text()
			 	 } 
	 	 };
		 local:run-emiss-by-enduse((:scenarios:), (:regions:), (:collection:))]]>
               </xPath>
         <comments/>
     </supplyDemandQuery>
      </aQuery>

    <aQuery>
      <all-regions/>
      <supplyDemandQuery title="Central electricity demand by demand sector">
         <axis1 name="sector">sector</axis1>
         <axis2 name="Year">demand-physical[@vintage]</axis2>
         <xPath buildList="true" dataName="input" group="false" sumAll="false">*[@type = 'sector']//*[@type='input' (:collapse:) and (@name='electricity_net_ownuse')]/demand-physical/node()</xPath>
         <comments/>
      </supplyDemandQuery>
    </aQuery>

<aQuery>
      	<all-regions/>
      <supplyDemandQuery title="Energy consumption by sector">
         <axis1 name="sector">sector</axis1>
         <axis2 name="Year">demand-physical[@vintage]</axis2>
         <xPath buildList="true" dataName="input" group="false" sumAll="false">*[@type='sector']//*[@type='input']/demand-physical[@unit='EJ']/node()</xPath>
         <comments>Supply sectors only.</comments>
      </supplyDemandQuery>
</aQuery>

<aQuery>
      	<all-regions/>
      <supplyDemandQuery title="Energy consumption by subsector">
         <axis1 name="sector">sector</axis1>
         <axis2 name="Year">demand-physical[@vintage]</axis2>
         <xPath buildList="true" dataName="input" group="false" sumAll="false">*[@type='sector']/*[@type='subsector']//*[@type='input']/demand-physical[@unit='EJ']/node()</xPath>
         <comments>Supply sectors only.</comments>
      </supplyDemandQuery>
</aQuery>

<aQuery>
      	<all-regions/>
		<query title="Land Use Change Emission (future)">
         <axis1 name="land-use-change-emission">LandLeaf</axis1>
         <axis2 name="Year">land-use-change-emission[@year]</axis2>
         <xPath buildList="true" dataName="land-use-change-emission" group="false" sumAll="true">/LandNode[@name='root' or @type='LandNode' (: collapse :)]//land-use-change-emission[@year&gt;1975]/text()</xPath>
         <comments/>
      	</query>
  </aQuery>

<aQuery>
      	<all-regions/>
		<emissionsQueryBuilder title="Resource GHG emissions">
         <axis1 name="GHG">GHG</axis1>
         <axis2 name="Year">emissions</axis2>
         <xPath buildList="true" dataName="emissions" group="false" sumAll="false">*[@type = 'resource']//*[@type = 'GHG']/emissions/node()</xPath>
         <comments/>
      </emissionsQueryBuilder>
  </aQuery>

  <aQuery>
      	<all-regions/>
		<emissionsQueryBuilder title="Sector GHG emissions">
         <axis1 name="GHG">GHG</axis1>
         <axis2 name="Year">emissions</axis2>
         <xPath buildList="true" dataName="emissions" group="false" sumAll="false">*[@type = 'sector']//*[@type = 'GHG']/emissions/node()</xPath>
         <comments/>
      </emissionsQueryBuilder>
  </aQuery>

  <aQuery>
      	<all-regions/>
		<emissionsQueryBuilder title="Subsector GHG emissions">
         <axis1 name="GHG">GHG</axis1>
         <axis2 name="Year">emissions</axis2>
         <xPath buildList="true" dataName="emissions" group="false" sumAll="false">*[@type = 'sector']/*[@type='subsector']//*[@type = 'GHG']/emissions/node()</xPath>
         <comments/>
         </emissionsQueryBuilder>
  </aQuery>

  <aQuery>
      	<all-regions/>
		<emissionsQueryBuilder title="Technology GHG emissions">
         <axis1 name="GHG">GHG</axis1>
         <axis2 name="Year">emissions</axis2>
         <xPath buildList="true" dataName="emissions" group="false" sumAll="false">*[@type = 'sector']/*[@type='subsector']/*[@type='technology']//*[@type = 'GHG']/emissions/node()</xPath>
         <comments/>
      </emissionsQueryBuilder>
  </aQuery>

  <aQuery>
        <all-regions/>
            <supplyDemandQuery title="Consumption by technology">
                <axis1 name="input">input</axis1>
                <axis2 name="Year">demand-physical[@vintage]</axis2>
                <xPath buildList="true" dataName="input" group="false" sumAll="false">*[@type='sector']/*[@type='subsector']/*[@type='technology']/*[@type='input']/demand-physical/node()</xPath>
                <comments>Supply sectors only.</comments>
            </supplyDemandQuery>
    </aQuery>

    <aQuery>
        <all-regions/>
            <supplyDemandQuery title="Service output by technology">
                <axis1 name="sector">sector[@name]</axis1>
                <axis2 name="Year">physical-output[@vintage]</axis2>
                <xPath buildList="true" dataName="output" group="false" sumAll="false">*[@type='sector']/*[@type='subsector']/*[@type='technology']/*[@type='output']/physical-output[@unit='EJ']/node()</xPath>
                <comments/>
            </supplyDemandQuery>
    </aQuery>

    <aQuery>
        <all-regions/>
            <emissionsQueryBuilder title="CO2 sequestration by sector">
         <axis1 name="sector">sector</axis1>
         <axis2 name="Year">emissions-sequestered</axis2>
         <xPath buildList="true" dataName="emissions" group="false" sumAll="false">*[@type = 'sector' ]//*[@type = 'technology' (:collapse:) and (exists(child::output-primary))]//CO2/emissions-sequestered/node()</xPath>
         <comments/>
         <labelRewriteList append-values="false">
            <level name="sector">
               <rewrite from="backup_electricity" to="electricity"/>
               <rewrite from="csp_backup" to="electricity"/>
            </level>
         </labelRewriteList>
      </emissionsQueryBuilder>
    </aQuery>
    
    <aQuery>
        <all-regions/>
    <supplyDemandQuery title="ag production by crop type">
        <axis1 name="sector">sector[@name]</axis1>
        <axis2 name="Year">physical-output[@vintage]</axis2>
        <xPath buildList="true" dataName="output" group="false" sumAll="false">*[@type='sector' and (local-name()='AgSupplySector')]//
            output-primary/physical-output/node()</xPath>
        <comments>primary output only (no residue biomass)</comments>
    </supplyDemandQuery>
 </aQuery>

 <aQuery>
        <all-regions/>
    <query title="LUC emissions by LUT">
            <axis1 name="LandLeaf">LandLeaf</axis1>
            <axis2 name="Year">land-use-change-emission[@year]</axis2>
            <xPath buildList="true" dataName="land-use-change-emission" group="false" sumAll="false"><![CDATA[/LandNode[@name='root' or @type='LandNode' (:collapse:)]//
                land-use-change-emission[@year>1970]/text()]]></xPath>
            <comments/>
         </query>
 </aQuery>

 <aQuery>
        <all-regions/>
    <query title="detailed land allocation">
            <axis1 name="LandLeaf">LandLeaf[@name]</axis1>
            <axis2 name="Year">land-allocation[@year]</axis2>
            <xPath buildList="true" dataName="LandLeaf" group="false" sumAll="false">/LandNode[@name='root' or @type='LandNode' (:collapse:)]//land-allocation/text()</xPath>
            <comments/>
         </query>
 </aQuery>



</queries>
